# Mattermost Server Development Guide for AI Systems

## Context and Purpose
This guide is designed for AI systems involved in Mattermost server development. It contains essential patterns, conventions, and requirements for writing and maintaining server-side code.

## Code Style and Standards

### Golang Conventions
1. Code Formatting
- All code must pass `gofmt` tool validation
- Formatting is enforced in CI pipeline
- Follow Effective Go guidelines (https://golang.org/doc/effective_go.html)
- Adhere to Go Code Review Comments (https://go.dev/wiki/CodeReviewComments)

2. Naming Conventions
- Use CamelCase for variables/constants (e.g., WebsocketEventPostEdited)
- Receiver names should reflect identity (e.g., "c" or "cl" for "Client")
- Error variables must be named 'err' or prefixed with 'err'
- AppError variables must be named 'appErr' or prefixed with 'appErr'
- Interface names should end with "-er"

3. Project Structure
- Follow standard Go module layout guidelines
- Avoid using 'pkg', 'util', or 'misc' packages
- Group related functionality into meaningful packages
- Don't create too many small single-file packages

### Programming Patterns

1. Function Design
- Default to synchronous over asynchronous functions
- Don't create one-off goroutines without lifecycle management
- Return structs, accept interfaces
- Avoid creating new ToJSON methods, use json.Marshal instead

2. Error Handling
- Reduce indentation in error handling
- Remove else blocks when multiple return statements exist
- Proper error variable naming based on type (err vs appErr)

3. Performance Considerations
- Requires performance review for:
  * New features needing benchmarks
  * Changes to critical components (Hub/WebConn)
  * SQL query modifications
  * Goroutine creation
  * Memory-intensive operations
  * Synchronization primitives usage
  * Regular expressions
  * Reflect package usage

### Logging Guidelines

1. Log Levels and Usage
- Critical: Service unable to continue operating
- Error: Unexpected issues, but service continues
- Warn: Unexpected but non-fatal issues
- Info: Normal application behavior
- Debug: Diagnostic information

2. Log Format
- Use key-value pairs for context
- Keys should use snake_case
- Reference JSON struct tags for key names
- Include relevant identifiers (user_id, post_id, etc.)

## Testing Requirements

1. Performance Testing
- Required for performance-sensitive changes
- Must include benchmarks for new features
- Load testing coverage for critical paths

2. Code Review Focus
- Performance impact assessment
- Goroutine lifecycle management
- Resource utilization
- Error handling patterns
- Logging appropriateness

## Best Practices

1. Interface Design
- Define interfaces at consumer side
- Keep interfaces focused and small
- Allow interface composition
- Test using public APIs when possible

2. Memory Management
- Pre-allocate slices and maps when size is known
- Avoid unnecessary allocations
- Use Buffer.Grow appropriately
- Be cautious with large slice operations

3. Synchronization
- Minimize lock scope
- Prefer sync.Mutex over channels for simple synchronization
- Document complex synchronization patterns

## Common Patterns to Avoid

1. Anti-patterns
- Preemptive interface creation
- Unnecessary async operations
- Pointer usage for slices
- Generic package names (util, misc)
- Unexported interface methods
- Unbounded goroutine creation

2. Performance Pitfalls
- Dynamic regexp compilation
- Unnecessary reflection
- Unbounded loops
- Uncontrolled resource growth
- Lock contention

This guide serves as a reference for AI systems to maintain consistency and quality in Mattermost server development. Follow these guidelines to ensure code aligns with project standards and performs optimally.

## Developer Workflow

### Repository Structure
- ./server/channels/api4/: API and application related code
- ./server/public/model/: Data model definitions and Go driver
- ./server/channels/store/: Database querying code
- ./server/channels/utils/: Utilities (mail, etc.)
- ./server/i18n/: Localization files

### Development Process
1. Create feature branches named 'MM-$NUMBER_$DESCRIPTION'
   - $NUMBER = Jira ticket number
   - $DESCRIPTION = Short description
   - Example: MM-18150_plugin-panic-log

2. Testing Requirements:
   - Write/modify unit tests using testify
   - Test files must end with _test.go
   - Place tests in same folder as tested code
   - Run 'make store-mocks' and 'make store-layers' for store changes
   - Use 'make run-server' to start server at http://localhost:8065
   - Use 'make check-style' for syntax checking
   - Run tests with:
     * make test (all tests)
     * go test -run "TestName" ./<directory> (individual)
     * go test <package> (package tests)

3. Key Make Commands:
   - make run: Run server with webapp watcher
   - make stop: Stop server and webapp
   - make run-server: Run server only
   - make debug-server: Run with delve debugger
   - make update-docker: Update Docker images
   - make clean-docker: Remove Docker images
   - make config-reset: Reset config.json
   - make nuke: Fresh environment reset
   - make package: Create distribution packages

4. CLI Tools:
   - mattermost db reset: Reset database
   - mmctl sampledata: Generate test data
   - mmctl user create: Create users
   
5. Environment Customization:
   - Use config.override.mk for Makefile variables
   - Create docker-compose.override.yaml for custom services

6. Email Testing:
   - SMTP server available on port 2500
   - Inbucket webmail on port 9000
   - No authentication required

7. GitLab Testing:
   - Replace binary in /opt/gitlab/embedded/bin/mattermost
   - Update assets in /opt/gitlab/embedded/service/mattermost

8. Pull Request Guidelines:
   - Avoid rebasing after PR submission
   - Avoid force-pushing to PR branches
   - Commits will be automatically squashed on merge

## REST API Development

### Adding New API Endpoints

1. Documentation Requirements:
   - Use OpenAPI specification in api/v4/source/*.yaml files
   - Document endpoint with:
     * Tag (resource type)
     * Summary (few words)
     * Description (1-2 sentences)
     * Permissions required
     * Parameters (URL and body)
     * Responses (success and error cases)
   - Validate docs with 'make build' in api/ directory

2. Implementation Steps:
   - Add endpoint declaration in appropriate api4/*.go file
   - Follow handler pattern:
     ```
     func handlerName(c *Context, w http.ResponseWriter, r *http.Request) {
         // 1. Parse request URL and body
         // 2. Check permissions
         // 3. Invoke app package logic
         // 4. Check Etag (optional)
         // 5. Format and write response
     }
     ```

3. Golang Driver Updates:
   - Add client function in model/client4.go
   - Place in appropriate section (Teams, Users, etc.)
   - Match HTTP method to endpoint

4. Testing Requirements:
   - Create unit test in api4/*_test.go
   - Test coverage must include:
     * All valid input combinations
     * Etag handling if applicable
     * Error cases:
       - 400 Bad Request for invalid parameters
       - 401 Unauthorized for missing token
       - 403 Forbidden for insufficient permissions
       - 404 Not Found for non-existent resources
   - Use helper functions from api4/apitestlib.go

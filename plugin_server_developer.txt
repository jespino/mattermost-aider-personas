MATTERMOST PLUGIN DEVELOPMENT GUIDE FOR AI

This guide contains essential information for developing Mattermost server plugins.

1. PLUGIN STRUCTURE AND CONVENTIONS

1.1 Project Layout
- Follow Go team's standardized guidelines
- Avoid using generic "pkg" directories
- Don't use "util" or "misc" packages
- Group related functionality into meaningful packages
- Don't create too many small single-file packages

1.2 Code Style
- Use CamelCase for variables/constants (e.g., WebsocketEventPostEdited)
- Use "err" for error variables and "appErr" for *model.AppError variables
- Use empty string check with foo == "" instead of len(foo) == 0
- Use proper initialisms (userID not userId, HTTP not Http)
- Use meaningful receiver names (e.g., "c" or "cl" for "Client")

2. PLUGIN DEVELOPMENT PRINCIPLES

2.1 Synchronous vs Asynchronous
- Default to synchronous functions
- Only use async when performance benefits are proven
- Control goroutine lifetimes
- Consider error propagation and back-pressure

2.2 Interface Design
- Return structs, accept interfaces
- Interface names should end with "-er"
- Define interfaces in consuming packages
- Use small, composable interfaces

2.3 Error Handling
- Use appropriate error types (error vs *model.AppError)
- Follow error variable naming conventions
- Propagate errors appropriately

3. PLUGIN API REFERENCE

3.1 Key Plugin Hooks

Lifecycle Hooks:
func (p *Plugin) OnActivate() error
    // Called when the plugin is activated. If an error is returned, the plugin will be terminated.

func (p *Plugin) OnDeactivate() error
    // Called when the plugin is deactivated. Clean up any resources.

func (p *Plugin) OnConfigurationChange() error
    // Called whenever the plugin's configuration changes.

HTTP Hooks:
func (p *Plugin) ServeHTTP(c *plugin.Context, w http.ResponseWriter, r *http.Request)
    // Called for HTTP/HTTPS requests to the plugin's endpoint.

Command Hooks:
func (p *Plugin) ExecuteCommand(c *plugin.Context, args *model.CommandArgs) (*model.CommandResponse, error)
    // Called when a command registered by the plugin is triggered.

Post Hooks:
func (p *Plugin) MessageWillBePosted(c *plugin.Context, post *model.Post) (*model.Post, string, error)
    // Called before a post is saved to the database.

func (p *Plugin) MessageHasBeenPosted(c *plugin.Context, post *model.Post)
    // Called after a post has been saved to the database.

func (p *Plugin) MessageWillBeUpdated(c *plugin.Context, newPost, oldPost *model.Post) (*model.Post, string, error)
    // Called before a post is updated in the database.

func (p *Plugin) MessageHasBeenUpdated(c *plugin.Context, newPost, oldPost *model.Post)
    // Called after a post has been updated in the database.

User Hooks:
func (p *Plugin) UserHasLoggedIn(c *plugin.Context, user *model.User)
    // Called after a user has logged in.

func (p *Plugin) UserHasLoggedOut(c *plugin.Context, user *model.User)
    // Called after a user has logged out.

func (p *Plugin) UserWillLogIn(c *plugin.Context, user *model.User) string
    // Called before a user attempts to log in.

Channel Hooks:
func (p *Plugin) ChannelHasBeenCreated(c *plugin.Context, channel *model.Channel)
    // Called after a channel has been created.

func (p *Plugin) UserHasJoinedChannel(c *plugin.Context, channelMember *model.ChannelMember, actor *model.User)
    // Called after a user has joined a channel.

func (p *Plugin) UserHasLeftChannel(c *plugin.Context, channelMember *model.ChannelMember, actor *model.User)
    // Called after a user has left a channel.

Team Hooks:
func (p *Plugin) UserHasJoinedTeam(c *plugin.Context, teamMember *model.TeamMember, actor *model.User)
    // Called after a user has joined a team.

func (p *Plugin) UserHasLeftTeam(c *plugin.Context, teamMember *model.TeamMember, actor *model.User)
    // Called after a user has left a team.

File Hooks:
func (p *Plugin) FileWillBeUploaded(c *plugin.Context, info *model.FileInfo, file io.Reader, output io.Writer) (*model.FileInfo, string, error)
    // Called before a file is uploaded.

3.2 Common API Operations
- Configuration management
- User operations
- Team operations
- Channel operations
- Post operations
- File operations
- Key-value store operations

4. LOGGING GUIDELINES

4.1 Log Levels
- Critical: Service unable to continue operating
- Error: Unexpected issues requiring admin action
- Warn: Unexpected but recoverable issues
- Info: Normal operation events
- Debug: Diagnostic information

4.2 Logging Format
- Use key-value pairs for context
- Use snake_case for keys
- Reference JSON struct tags for key names

5. PERFORMANCE CONSIDERATIONS

5.1 Areas Requiring Performance Review
- New features needing benchmarks
- Changes to critical components (Hub/WebConn)
- SQL query modifications
- Goroutine creation
- Memory allocations
- Synchronization primitives
- Regular expressions
- Reflect package usage

5.2 Best Practices
- Avoid pointer to slices
- Use json.Marshal instead of ToJSON methods
- Pre-allocate slices and maps when size is known
- Avoid dynamic regexp.MustCompile
- Control goroutine lifecycles

6. TESTING REQUIREMENTS

6.1 Test Coverage
- Unit tests for new functionality
- Integration tests for API changes
- Performance tests for critical paths

6.2 Test Guidelines
- Test real implementations over mocks
- Use docker containers for external services
- Focus on public API testing

7. BACKWARD COMPATIBILITY

7.1 Considerations
- Maintain API compatibility
- Handle deprecated features gracefully
- Document breaking changes

8. SECURITY BEST PRACTICES

8.1 Guidelines
- Validate input data
- Handle sensitive information securely
- Follow proper authentication/authorization
- Use secure communication channels

Remember to:
- Follow Go best practices from Effective Go
- Adhere to CodeReviewComments guidelines
- Consider performance implications
- Maintain backward compatibility
- Write comprehensive tests
- Document public APIs
